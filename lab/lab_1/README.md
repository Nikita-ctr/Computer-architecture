# Микрогайд
Создаем файлы filename.c коммандой:
~~~
touch filename.c
~~~
Далее созадем Makefile таким же образом

При сборке файла может возникунуть ряд проблем связанных либо с макросом MODULE_LICENSE() который обязателен для всех модулей ядра и указывает на тип лицензии, используемой для данного модуля(в нашем случае GPL).Так же проблема может возникнуть с kernel headers(при загрузке модуля ядра в оперативную память с помощью insmod) одно из решений может быть простая переустановка kernel headers 
~~~
sudo apt update && sudo apt upgrade
sudo apt remove --purge linux-headers-*
sudo apt autoremove && sudo apt autoclean
sudo apt install linux-headers-generic
~~~

После загрузки модуля коммандой insmod нужно проверить вывод модуля ядра, введя следующую команду в терминале:
~~~
sudo dmesg
~~~
Эта команда выведет в терминал логи ядра, включая вывод нашего модуля

В данном случае, число выводимое при загрузке модуля, которое выводится в журнал ядра, является значением, прочитанным из регистра 0x02.
Адреса портов 0x70 и 0x71 используются для чтения и записи значений в регистры RTC (Real Time Clock) на материнской плате компьютера.
RTC - это устройство, которое хранит текущую дату и время в момент выключения компьютера. При следующем включении компьютера время и дата считываются из регистров RTC.

5)В подкаталоге /proc содержится множество файлов, которые предоставляют информацию о различных аспектах работы операционной системы, включая информацию об установленном оборудовании.
Для выполнения данного задания необходимо знать, где в NVRAM хранится информация о размере установленной оперативной памяти. В общем случае эта информация находится в структуре SMBIOS (System Management BIOS), которая хранится в NVRAM. В файловой системе Linux информация о системе содержится в различных файлах, которые находятся в каталоге /proc.

Один из файлов, содержащих информацию о системе, это файл /proc/meminfo. Он содержит информацию об использовании памяти системой, включая общий объем памяти, доступный для использования.

Для сравнения с данными, хранящимися в NVRAM, можно воспользоваться утилитой dmidecode, которая может прочитать информацию о SMBIOS из NVRAM. Чтобы узнать размер установленной оперативной памяти, необходимо выполнить следующую команду в терминале:
~~~
sudo dmidecode -t memory | grep Size
~~~

Эта команда выводит информацию о размере каждого установленного модуля памяти.

Пример содержимого файла /proc/meminfo:	
~~~
MemTotal:       16345068 kB
MemFree:        12302936 kB
MemAvailable:   15078488 kB
Buffers:          356176 kB
Cached:          2359048 kB
SwapCached:            0 kB
Active:          2157972 kB
Inactive:        2146676 kB
Active(anon):    1386852 kB
Inactive(anon):   662104 kB
Active(file):     771120 kB
Inactive(file):  1484572 kB
~~~

Пример вывода команды dmidecode:
~~~
	Size: 8 GB
	Non-Volatile Size: None
	Volatile Size: 8 GB
	Cache Size: None
	Logical Size: None
	Size: 8 GB
	Non-Volatile Size: None
	Volatile Size: 8 GB
	Cache Size: None
	Logical Size: None
~~~

Сравнивая эти данные, можно убедиться в том, что размер установленной оперативной памяти, который выводится командой dmidecode, соответствует значению, указанному в файле /proc/meminfo в строке "MemTotal".

# Контрольные вопросы:

1)Объясните, как реализована аппаратная защита памяти в современных компьютерах

~~~
Современные процессоры обеспечивают аппаратную защиту памяти с помощью механизма виртуальной памяти. 
Виртуальная память - это механизм, который позволяет ОС выделить 
каждому процессу отдельное адресное пространство, которое он может использовать для своих нужд. 
Процесс не имеет доступа к памяти других процессов или к памяти, которая принадлежит ОС.
Виртуальная память реализуется с помощью механизма страниц, которые представляют собой фрагменты 
физической памяти фиксированного размера. Операционная система использует таблицы страниц, 
чтобы отображать виртуальные адреса на физические адреса в памяти. Каждая страница имеет свои 
права доступа, которые определяют, может ли процесс читать или записывать в эту страницу. 
Если процесс пытается получить доступ к странице, которая не принадлежит ему или для которой у 
него нет прав доступа, процессор генерирует исключение, и ОС может прервать выполнение процесса.
В дополнение к виртуальной памяти, процессоры могут также обеспечивать аппаратную защиту с 
помощью режимов работы процессора. Например, Intel процессоры имеют два режима работы: 
пользовательский режим и режим ядра (англ. kernel mode). Пользовательский режим используется 
для выполнения приложений, а режим ядра используется для выполнения операционной системы 
и ее драйверов. Процессоры ограничивают доступность инструкций и ресурсов в пользовательском 
режиме, что обеспечивает дополнительную защиту от несанкционированного доступа к памяти.
~~~

2)Что такое модули ядра, зачем они нужны (вообще и конкретно в данной работе)?
~~~
Модули ядра (англ. kernel modules) - это программные компоненты, 
которые могут быть динамически загружены и выгружены в ядро операционной системы во время работы системы. 
Они позволяют добавлять новую функциональность в ядро без необходимости перекомпиляции всей операционной системы.
Модули ядра могут использоваться для добавления драйверов устройств, сетевых протоколов,
файловых систем, системных вызовов и других компонентов в ядро. 
Они также могут использоваться для изменения параметров ядра или его поведения.
В данной работе модули ядра, скорее всего, используются для добавления новой 
функциональности в ядро Linux. Это может быть, например, драйвер устройства для работы с 
определенным оборудованием или модуль для поддержки определенного сетевого протокола.
Преимущества использования модулей ядра включают возможность добавления новой функциональности
без перезагрузки системы и уменьшение размера ядра, 
так как модули могут быть загружены только при необходимости. Однако, использование модулей 
ядра может привести к увеличению потребления 
памяти и накладным расходам на управление ими во время выполнения системы.
~~~

3)Как выполнить загрузку модуля ядра в память?
~~~
Для загрузки модуля ядра в память в Linux необходимо выполнить следующие шаги:

* Скомпилировать исходный код модуля в объектный файл, используя команду gcc или другой компилятор. Например

gcc -c my_module.c -o my_module.o

* Собрать объектный файл в файл модуля ядра формата .ko с помощью утилиты ld. Например:

ld -r my_module.o -o my_module.ko

* Загрузить модуль ядра в память с помощью команды insmod. Например:

sudo insmod my_module.ko

* Проверить, что модуль был успешно загружен с помощью команды lsmod, которая отображает список загруженных модулей ядра. Например:

lsmod | grep my_module
~~~

4)Назовите два уровня абстракции для доступа к портам ввода-вывода.
~~~
Уровень устройства (device-level) - этот уровень предоставляет абстракцию, которая 
скрывает особенности аппаратного обеспечения и позволяет работать с устройствами ввода-вывода в 
терминах простых операций чтения и записи. Для работы с устройствами на этом уровне
используются специальные инструкции ассемблера, такие как инструкции in и out в x86-совместимых системах.

Уровень драйвера устройства (device driver level) - этот уровень предоставляет 
абстракцию, которая скрывает детали устройства ввода-вывода и позволяет приложениям работать с 
устройствами через стандартизированный интерфейс. Драйверы устройств выполняют 
перевод между операциями ввода-вывода на уровне устройства и высокоуровневыми операциями 
ввода-вывода, которые могут использоваться приложениями, например, операциями чтения и записи файлов.
~~~

5)Какая информация хранится в области NVRAM (CMOS)?
~~~
NVRAM (Non-Volatile Random Access Memory) или CMOS (Complementary Metal-Oxide-Semiconductor) - это специальная 
область памяти на материнской плате компьютера, 
которая хранит информацию о системных настройках, таких как:

* Дата и время: NVRAM хранит текущую дату и время, что позволяет системе отслеживать
время и дату с точностью до секунды.

* Настройки устройств: NVRAM может содержать информацию о настройках различных устройств, 
таких как жесткие диски, оптические приводы, звуковые карты и т.д.

* Параметры BIOS: NVRAM также может содержать информацию о настройках 
BIOS (Basic Input/Output System), например, параметры памяти, настройки разгона процессора и т.д.

* Серийные номера: NVRAM может хранить серийные номера компьютера, 
материнской платы и других устройств, что может быть полезно при обслуживании и ремонте.

* Пароли и ключи: Некоторые системы хранят пароли и ключи шифрования в 
NVRAM, чтобы предотвратить несанкционированный доступ к системе и ее данным.

В общем, NVRAM содержит информацию, которая сохраняется при выключении компьютера и 
используется для настройки и запуска системы при следующем включении.
~~~

6)Расскажите об общей структуре виртуальной файловой системы proc.
~~~
Procfs (Proc Filesystem) - это виртуальная файловая система, которая 
предоставляет информацию о процессах и системных ресурсах в Linux.

Структура файловой системы proc в целом отражает структуру процессов в системе. 
В корневой директории /proc каждый запущенный процесс имеет свою директорию с именем, 
соответствующим его идентификатору процесса (PID). Кроме того, в файловой 
системе proc есть ряд общих файлов и директорий, которые предоставляют информацию о системных ресурсах и конфигурации.

Некоторые из наиболее распространенных файлов и директорий в файловой системе proc:

* /proc/cpuinfo - содержит информацию о процессоре и его характеристиках, таких как количество ядер и частота процессора.

* /proc/meminfo - содержит информацию об использовании памяти, такую как количество свободной и занятой памяти.

* /proc/net - содержит информацию о сетевых подключениях и статистику использования сетевых ресурсов.

* /proc/sys - содержит файлы, которые позволяют изменять конфигурацию ядра системы.

* /proc/self - является символической ссылкой на директорию, соответствующую текущему процессу, и позволяет процессу получать информацию о своих собственных ресурсах и характеристиках.

* /proc/[PID]/status - содержит информацию о статусе и ресурсах, используемых процессом с заданным идентификатором процесса (PID).

* /proc/[PID]/mem - содержит информацию о памяти, используемой процессом с заданным идентификатором процесса (PID).

Это лишь некоторые примеры файлов и директорий в файловой системе proc,
но в целом структура файловой системы proc соответствует структуре 
процессов и системных ресурсов в Linux, и предоставляет программистам и 
администраторам множество возможностей для отслеживания и управления системой.
~~~
